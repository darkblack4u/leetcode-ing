> ## Java 基础

**1.JDK 和 JRE 有什么区别？**

'''

'''

**2.== 和 equals 的区别是什么？**

3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？

4.final 在 java 中有什么作用？

5.java 中的 Math.round(-1.5) 等于多少？

6.String 属于基础的数据类型吗？

7.java 中操作字符串都有哪些类？它们之间有什么区别？

8.String str="i"与 String str=new String(“i”)一样吗？

9.如何将字符串反转？

10.String 类的常用方法都有那些？

11.抽象类必须要有抽象方法吗？

12.普通类和抽象类有哪些区别？

13.抽象类能使用 final 修饰吗？

14.接口和抽象类有什么区别？

15.java 中 IO 流分为几种？

16.BIO、NIO、AIO 有什么区别？

17.Files的常用方法都有哪些？

> ## 容器

18.java 容器都有哪些？

19.Collection 和 Collections 有什么区别？

20.List、Set、Map 之间的区别是什么？

21.HashMap 和 Hashtable 有什么区别？

22.如何决定使用 HashMap 还是 TreeMap？

23.说一下 HashMap 的实现原理？

24.说一下 HashSet 的实现原理？

25.ArrayList 和 LinkedList 的区别是什么？

26.如何实现数组和 List 之间的转换？

27.ArrayList 和 Vector 的区别是什么？

28.Array 和 ArrayList 有何区别？

29.在 Queue 中 poll()和 remove()有什么区别？

30.哪些集合类是线程安全的？

31.迭代器 Iterator 是什么？

32.Iterator 怎么使用？有什么特点？

33.Iterator 和 ListIterator 有什么区别？

34.怎么确保一个集合不能被修改？

> ## 多线程

35.并行和并发有什么区别？

36.线程和进程的区别？

37.守护线程是什么？

38.创建线程有哪几种方式？

39.说一下 runnable 和 callable 有什么区别？

40.线程有哪些状态？

41.sleep() 和 wait() 有什么区别？

42.notify()和 notifyAll()有什么区别？

43.线程的 run()和 start()有什么区别？

44.创建线程池有哪几种方式？

45.线程池都有哪些状态？

46.线程池中 submit()和 execute()方法有什么区别？

47.在 java 程序中怎么保证多线程的运行安全？

48.多线程锁的升级原理是什么？

49.什么是死锁？

50.怎么防止死锁？

51.ThreadLocal 是什么？有哪些使用场景？

52.说一下 synchronized 底层实现原理？

53.synchronized 和 volatile 的区别是什么？

54.synchronized 和 Lock 有什么区别？

55.synchronized 和 ReentrantLock 区别是什么？

56.说一下 atomic 的原理？

> ## 反射

57.什么是反射？

58.什么是 java 序列化？什么情况下需要序列化？

59.动态代理是什么？有哪些应用？

60.怎么实现动态代理？

五、对象拷贝

61.为什么要使用克隆？

62.如何实现对象克隆？

63.深拷贝和浅拷贝区别是什么？

> ## Java Web

64.jsp 和 servlet 有什么区别？

65.jsp 有哪些内置对象？作用分别是什么？

66.说一下 jsp 的 4 种作用域？

67.session 和 cookie 有什么区别？

68.说一下 session 的工作原理？

69.如果客户端禁止 cookie 能实现 session 还能用吗？

70.spring mvc 和 struts 的区别是什么？

71.如何避免 sql 注入？

72.什么是 XSS 攻击，如何避免？

73.什么是 CSRF 攻击，如何避免？

> ## 异常

**74.throw 和 throws 的区别？**

```
throw：表示方法内抛出某种异常对象，如果异常对象是非 RuntimeException 则需要在方法申明时加上该异常的抛出，即需要加上 throws 语句 或者 在方法体内 try catch 处理该异常，否则编译报错
执行到 throw 语句则后面的语句块不再执行。
throws：方法的定义上使用 throws 表示这个方法可能抛出某种异常，需要由方法的调用者进行异常处理。

原文链接：https://blog.csdn.net/meism5/article/details/90414147
```

**75.final、finally、finalize 有什么区别？**
```
一、final ：

1、修饰符（关键字） 如果一个类被声明为final,意味着它不能再派生新的子类，不能作为父类被继承。因此一个类不能及被声明为abstract，又被声明为final的。

2、将变量或方法声明为final,可以保证他们使用中不被改变。被声明为final的变量必须在声明时给定初值，而以后的引用中只能读取，不可修改，被声明为final的方法也同样只能使用，不能重载。

二、finally:

在异常处理时提供finally块来执行清楚操作。如果抛出一个异常，那么相匹配的catch语句就会执行，然后控制就会进入finally块，如果有的话。

三、finalize：

是方法名。java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除之前做必要的清理工作。这个方法是在垃圾收集器在确定了，被清理对象没有被引用的情况下调用的。
```

**76.try-catch-finally 中哪个部分可以省略？**
```
catch 和 finally 语句块可以省略其中一个,否则编译会报错。
```

**77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？**
```
会执行，在return 前执行。如果finally里面也有return，就以finally里面的为主。
```

**78.常见的异常类有哪些？**
```
(1) NullPointerException 当应用程序试图访问空对象时，则抛出该异常。
(2) SQLException 提供关于数据库访问错误或其他错误信息的异常。
(3) IndexOutOfBoundsException指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 
(4) NumberFormatException当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。
(5) FileNotFoundException当试图打开指定路径名表示的文件失败时，抛出此异常。
(6) IOException当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。
(7) ClassCastException当试图将对象强制转换为不是实例的子类时，抛出该异常。
(8) ArrayStoreException试图将错误类型的对象存储到一个对象数组时抛出的异常。
(9) IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。
(10) ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 
(11) NegativeArraySizeException如果应用程序试图创建大小为负的数组，则抛出该异常。
(12) NoSuchMethodException无法找到某一特定方法时，抛出该异常。
(13) SecurityException由安全管理器抛出的异常，指示存在安全侵犯。
(14) UnsupportedOperationException当不支持请求的操作时，抛出该异常。
(15) RuntimeExceptionRuntimeException 是那些可能在Java虚拟机正常运行期间抛出的异常的超类。
```

> ## 网络

**79.http 响应码 301 和 302 代表的是什么？有什么区别？**
```
301 moved permanently、302 found、303 see other

301/302/303都表示重定向，所以放在一起讲解。

301表示永久重定向（301 moved permanently），表示请求的资源分配了新url，以后应使用新url。

302表示临时性重定向（302 found），请求的资源临时分配了新url，本次请求暂且使用新url。302与301的区别是，302表示临时性重定向，重定向的url还有可能还会改变。

303 表示请求的资源路径发生改变，使用GET方法请求新url。她与302的功能一样，但是明确指出使用GET方法请求新url。
————————————————
原文链接：https://blog.csdn.net/wangjun5159/article/details/51239960
```

**80. forward 和 redirect 的区别？**
```
是servlet种的两种主要的跳转方式。forward又叫转发，redirect叫做重定向。
1. 从地址栏显示来说：
    1）forword是服务器内部的重定向，服务器直接访问目标地址的 url网址，把里面的东西读取出来，但是客户端并不知道，因此用forward的话，客户端浏览器的网址是不会发生变化的。
    2）redirect是服务器根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，所以地址栏显示的是新的地址。
2。 从数据共享来说：
    1）由于在整个定向的过程中用的是同一个request，因此forward会将request的信息带到被重定向的jsp或者servlet中使用。即可以共享数据
    2）redirect不能共享
3. 从运用的地方来说
    1）forword 一般用于用户登录的时候，根据角色转发到相应的模块
    2）redirect一般用于用户注销登录时返回主页面或者跳转到其他网站
4。 从效率来说：
    1）forword效率高，而redirect效率低
5. 从本质来说：
    forword转发是服务器上的行为，而redirect重定向是客户端的行为
————————————————
原文链接：https://blog.csdn.net/weixin_37766296/article/details/80375106
```

**81. 简述 tcp 和 udp的区别？**
```
TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，三次对话建立连接，四次对话断开连接。
UDP的包头结构：源端口 16位 目的端口 16位 长度 16位 校验和 16位
小结TCP与UDP的区别：
1、基于连接与无连接；
2、对系统资源的要求（TCP较多，UDP少）；
3、UDP程序结构较简单；
4、流模式与数据报模式 ；
5、TCP保证数据正确性，UDP可能丢包；
6、TCP保证数据顺序，UDP不保证。
```

**82. tcp 为什么要三次握手，两次不行吗？为什么？**
```
这样的两次握手过程， A 向 B 打招呼得到了回应，即 A 向 B 发送数据，B 是可以收到的。
但是 B 向 A 打招呼，A 还没有回应，B 没有收到 A 的反馈，无法确保 A 可以收到 B 发送的数据。
只有经过第三次握手，才能确保双向都可以接收到对方的发送的 数据。
```

**83.说一下 tcp 粘包是怎么产生的？**
```
1.Q：什么是TCP粘包问题？
    TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。

2.Q：造成TCP粘包的原因
（1）发送方原因

    TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：

    1 只有上一个分组得到确认，才会发送下一个分组
    2 收集多个小分组，在一个确认到来时一起发送
    3 Nagle算法造成了发送方可能会出现粘包问题

（2）接收方原因

    TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

3.Q：什么时候需要处理粘包现象？
    如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象，如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了
4.Q：如何处理粘包现象？
    （1）发送方
    对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。
    （2）接收方
    接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。
    （2）应用层
    应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。

    解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？
    格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。
    发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。

原文链接：https://blog.csdn.net/weixin_41047704/article/details/85340311
```

**84. OSI 的七层模型都有哪些？**
```
OSI模型分为七层，自下而上为 物理层（Physical Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表达层（Presentation Layer）、应用层（Application Layer）。

TCP/IP四层概念模型: 应用层，传输层，网络层，数据传输层
————————————————
https://blog.csdn.net/meism5/article/details/90414270
```

**85. get 和 post 请求有哪些区别？**

**86.如何实现跨域？**
```
JSONP：通过动态创建script，再请求一个带参网址实现跨域通信。document.domain + iframe跨域：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

JSONP：ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。

location.hash + iframe跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

window.name + iframe跨域：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。

postMessage跨域：可以跨域操作的window属性之一。

CORS：服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求，前后端都需要设置。

代理跨域：起一个代理服务器，实现数据的转发
```

87.说一下 JSONP 实现原理？

九、设计模式

88.说一下你熟悉的设计模式？

89.简单工厂和抽象工厂有什么区别？

十、Spring/Spring MVC

90.为什么要使用 spring？

91.解释一下什么是 aop？

92.解释一下什么是 ioc？

93.spring 有哪些主要模块？

94.spring 常用的注入方式有哪些？

95.spring 中的 bean 是线程安全的吗？

96.spring 支持几种 bean 的作用域？

97.spring 自动装配 bean 有哪些方式？

98.spring 事务实现方式有哪些？

99.说一下 spring 的事务隔离？

100.说一下 spring mvc 运行流程？

101.spring mvc 有哪些组件？

102.@RequestMapping 的作用是什么？

103.@Autowired 的作用是什么？

十一、Spring Boot/Spring Cloud

104.什么是 spring boot？

105.为什么要用 spring boot？

106.spring boot 核心配置文件是什么？

107.spring boot 配置文件有哪几种类型？它们有什么区别？

108.spring boot 有哪些方式可以实现热部署？

109.jpa 和 hibernate 有什么区别？

110.什么是 spring cloud？

111.spring cloud 断路器的作用是什么？

112.spring cloud 的核心组件有哪些？

十二、Hibernate

113.为什么要使用 hibernate？

114.什么是 ORM 框架？

115.hibernate 中如何在控制台查看打印的 sql 语句？

116.hibernate 有几种查询方式？

117.hibernate 实体类可以被定义为 final 吗？

118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？

119.hibernate 是如何工作的？

120.get()和 load()的区别？

121.说一下 hibernate 的缓存机制？

122.hibernate 对象有哪些状态？

123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？

124.hibernate 实体类必须要有无参构造函数吗？为什么？

十三、Mybatis

125.mybatis 中 #{}和 ${}的区别是什么？

126.mybatis 有几种分页方式？

127.RowBounds 是一次性查询全部结果吗？为什么？

128.mybatis 逻辑分页和物理分页的区别是什么？

129.mybatis 是否支持延迟加载？延迟加载的原理是什么？

130.说一下 mybatis 的一级缓存和二级缓存？

131.mybatis 和 hibernate 的区别有哪些？

132.mybatis 有哪些执行器（Executor）？

133.mybatis 分页插件的实现原理是什么？

134.mybatis 如何编写一个自定义插件？

十四、RabbitMQ

135.rabbitmq 的使用场景有哪些？

136.rabbitmq 有哪些重要的角色？

137.rabbitmq 有哪些重要的组件？

138.rabbitmq 中 vhost 的作用是什么？

139.rabbitmq 的消息是怎么发送的？

140.rabbitmq 怎么保证消息的稳定性？

141.rabbitmq 怎么避免消息丢失？

142.要保证消息持久化成功的条件有哪些？

143.rabbitmq 持久化有什么缺点？

144.rabbitmq 有几种广播类型？

145.rabbitmq 怎么实现延迟消息队列？

146.rabbitmq 集群有什么用？

147.rabbitmq 节点的类型有哪些？

148.rabbitmq 集群搭建需要注意哪些问题？

149.rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？

150.rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？

151.rabbitmq 对集群节点停止顺序有要求吗？

十五、Kafka

**152.kafka 可以脱离 zookeeper 单独使用吗？为什么？**
```
不可以，要通过zookeeper来保持一致性。
```

**153.kafka 有几种数据保留的策略？**
```
两种，设置ddl和最大空间
```

**154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？**
```
删除，只要触发一种条件，就删除
```

**155.什么情况会导致 kafka 运行变慢？**
```
cpu
性能瓶颈
磁盘读写瓶颈
网络瓶颈
```

**156.使用 kafka 集群需要注意什么？**
```
奇数，不要太多
```

十六、Zookeeper

157.zookeeper 是什么？
```
分布式的，开放源码的分布式应用程序协调服务
提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等
ZooKeeper的基本运转流程：
1、选举Leader。
2、同步数据。
3、选举Leader过程中算法有很多，但要达到的选举标准是一致的。
4、Leader要具有最高的执行ID，类似root权限。
5、集群中大多数的机器得到响应并接受选出的Leader。
```

**158.zookeeper 都有哪些功能？**
```
统一命名服务(naming)

分布式应用中,通常需要有一套完整的命名规则,既能狗产生唯一的命名又便于认识别和记住,通常情况下用树形的结构是一个理想的选择,属性的名称结构是一个有层次的目录结构,既对人友好又不会重复,说到这里你可能xiangdao`想到JNDO没错Zookeeper的Name Service与JNDI能够完成的功能是差不多的,他们都是酱油层次的目录结构关联到一定资源上,dansh但是Zookeeper的NameService更加是广泛意义上的关联,也许你并不需要将名称关联到特定资源上,你可能只需要一个不会重复的名称,就想数据库中产生唯一的数字主键一样.
NameService已经是Zookeeper内置的功能,nizh你只要调用Zookeeper的API就能实现,如调用create接口就可以很容易的创建一个目录节点.

配置管理

配置管理的在分布式应用环境下很常见,例如同一个应用系统需要多台PC Server运行,但是他们运行的应用系统的某些配置是相同的,如果要修改这个相同的配置项,那么就必须同时修改每台运行这个系统的PC Server这样非常麻烦而且容易出错.
像这样的配置信息完全可以交给Zookeeper来管理,将配置信息保存在Zookeeper的某个目录节点中,然后将所有需要修改的应用及其监控配置信息的状态,一旦配置信息发生变化,每台应用及其就会收到ZooKeeper的通知,然后从Zookeeper的通知,然后从Zookeeper获取新的配置信息应用到系统中

集群管理
Zookeeper能够很容易的实现集群管理的功能,如有多台Server组成一个服务集群,那么必须要一个总管知道当前及权重每台机器的服务状态,一旦有机器不能提供服务,集群中其他集群必须知道,从而做出调整重新分配服务政策.同样增加集群的服务能力时,就会增加一台或者多台server,同样也必须让总管知道.
Zookeeper不仅能够帮你维护当前的集群中机器的服务状态,而且能够帮你选出一个'总管',让这个总管来管理集群,这就是Zookeeper的另一个功能 Leader Election

它们的实现方式都是在 Zookeeper 上创建一个 EPHEMERAL 类型的目录节点，然后每个 Server 在它们创建目录节点的父目录节点上调用 getChildren(String path, boolean watch) 方法并设置 watch 为 true，由于是 EPHEMERAL 目录节点，当创建它的 Server 死去，这个目录节点也随之被删除，所以 Children 将会变化，这时 getChildren上的 Watch 将会被调用，所以其它 Server 就知道已经有某台 Server 死去了。新增 Server 也是同样的原理。
Zookeeper 如何实现 Leader Election，也就是选出一个 Master Server。和前面的一样每台 Server 创建一个 EPHEMERAL 目录节点，不同的是它还是一个 SEQUENTIAL 目录节点，所以它是个 EPHEMERAL_SEQUENTIAL 目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为我们可以给每台 Server 编号，我们可以选择当前是最小编号的 Server 为 Master，假如这个最小编号的 Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。

对列管理

Zookeeper 可以处理两种类型的队列：

1.当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。
2.队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。
同步队列用 Zookeeper 实现的实现思路如下：
创建一个父目录 /synchronizing，每个成员都监控标志（Set Watch）位目录 /synchronizing/start 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 /synchronizing/member_i 的临时目录节点，然后每个成员获取 / synchronizing 目录的所有目录节点，也就是 member_i。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 /synchronizing/start 的出现，如果已经相等就创建 /synchronizing/start。
```

**159.zookeeper 有几种部署模式？**
```
单机部署：一般用来检验Zookeeper基础功能，熟悉ZK各种基础操作及特性；
伪集群部署：在单台机器上部署集群，方便在本地验证集群模式下的各种功能；
集群部署：一般在生产环境使用，具备一致性、分区容错性；
```

**160.zookeeper 怎么保证主从节点的状态同步？**
```
Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。恢复模式：当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。因此，选主得到的leader保证了同步状态的进行，状态同步又保证了leader和Server具有相同的系统状态，当leader失去主权后可以在其他follower中选主新的leader。
```

**161.集群中为什么要有主节点？**
```
在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，
 
其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。
```

162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？
```
可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。
```

**163.说一下 zookeeper 的通知机制？**
```
客户端端会对某个 znode 建立一个 watcher 事件，
 
当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，
 
然后客户端可以根据 znode 变化来做出业务上的改变。
```

十七、MySql

**164.数据库的三范式是什么？**
```
第一范式：强调的是列的原子性，就是列不能够再分成其他几列；

第二范式：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖主键的一部分；

第三范式：任何非主属性不依赖于其他非主属性。
原文链接：https://blog.csdn.net/weixin_45022376/article/details/104551142
```

**165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？**
```
一般情况下，我们创建的表的类型是InnoDB，如果新增一条记录（不重启mysql的情况下），这条记录的id是8；但是如果重启（文中提到的）MySQL的话，这条记录的ID是6。因为InnoDB表只把自增主键的最大ID记录到内存中，所以重启数据库或者对表OPTIMIZE操作，都会使最大ID丢失。

但是，如果我们使用表的类型是MylSAM，那么这条记录的ID就是8。因为MylSAM表会把自增主键的最大ID记录到数据文件里面，重启MYSQL后，自增主键的最大ID也不会丢失。

注：如果在这7条记录里面删除的是中间的几个记录（比如删除的是3,4两条记录），重启MySQL数据库后，insert一条记录后，ID都是8。因为内存或者数据库文件存储都是自增主键最大ID
```

**166.如何获取当前数据库版本？**
```
select version();
```

**167.说一下 ACID 是什么？**
```

Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，
不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，
就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
 
Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
 
Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，
隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，
包括读未提交（Read uncommitted）、读提交（read committed）、
可重复读（repeatable read）和串行化（Serializable）。
 
Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
```

**168.char 和 varchar 的区别是什么？**
```
1. char类型的长度是固定的，varchar的长度是可变的。

   这就表示，存储字符串'abc'，使用char(10)，表示存储的字符将占10个字节（包括7个空字符），使用varchar2(10),，则表示只占3个字节，10是最大值，当存储的字符小于10时，按照实际的长度存储。超出长度都自动截取。

2.char类型的效率比varchar的效率稍高
char最多可以存放255个字符
varchar的最大长度为65535个字节，varchar可存放的字符数跟编码有关
字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766个字符
字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845个字符
```

**169.float 和 double 的区别是什么？**
```
float数值类型用于表示单精度浮点数值，而double数值类型用于表示双精度浮点数值，float和double都是浮点型，而decimal是定点型；

MySQL 浮点型和定点型可以用类型名称后加（M，D）来表示，M表示该值的总共长度，D表示小数点后面的长度，M和D又称为精度和标度，如float(7,4)的 可显示为-999.9999，MySQL保存值时进行四舍五入，如果插入999.00009，则结果为999.0001。

FLOAT和DOUBLE在不指 定精度时，默认会按照实际的精度来显示，而DECIMAL在不指定精度时，默认整数为10，小数为0。

注意float与double数据类型储存的是近似值，而decimal是字符串
```

**170.mysql 的内连接、左连接、右连接有什么区别？**
```
1.内连接,显示两个表中有联系的所有数据;

2.左链接,以左表为参照,显示所有数据,右表中没有则以null显示

3.右链接,以右表为参照显示数据，,左表中没有则以null显示
```

**171.mysql 索引是怎么实现的？**

**172.怎么验证 mysql 的索引是否满足需求？**
```
使用方法，在select语句前加上explain就可以了：

EXPLAIN SELECT surname,first_name form a,b WHERE a.id=b.id
EXPLAIN列的解释：

table：显示这一行的数据是关于哪张表的。

type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL。

possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句。

key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引。

key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好。

ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。

rows：MySQL认为必须检查的用来返回请求数据的行数。

Extra：关于MySQL如何解析查询的额外信息。
```

**173.说一下数据库的事务隔离？**
```
https://blog.csdn.net/fuzhongmin05/article/details/91126936
```

**174.说一下 mysql 常用的引擎？**
```
MySQL常用的四种引擎的介绍
（1）：MyISAM存储引擎：不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表
支持3种不同的存储格式，分别是：静态表；动态表；压缩表

静态表：表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。

动态表：记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能
压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支

（2）InnoDB存储引擎*
该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。 
InnoDB存储引擎的特点：支持自动增长列，支持外键约束

(3)：MEMORY存储引擎
Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。 
MEMORY存储引擎的表可以选择使用BTREE索引或者HASH索引，两种不同类型的索引有其不同的使用范围

Hash索引优点： 
Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 
Hash索引缺点： 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；
Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。

（4）MERGE存储引擎
Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。
```

175.说一下 mysql 的行锁和表锁？

176.说一下乐观锁和悲观锁？

**177.mysql 问题排查都有哪些手段？**
```
使用 show processlist 命令查看当前所有连接信息。
使用 explain 命令查询 SQL 语句执行计划。
开启慢查询日志，查看慢查询的 SQL。
```

**178.如何做 mysql 的性能优化？**
```
为搜索字段创建索引。
避免使用 select *，列出需要查询的字段。
垂直分割分表。
选择正确的存储引擎。
```

> ## Redis

179.redis 是什么？都有哪些使用场景？

180.redis 有哪些功能？

181.redis 和 memecache 有什么区别？

182.redis 为什么是单线程的？

183.什么是缓存穿透？怎么解决？

184.redis 支持的数据类型有哪些？

185.redis 支持的 java 客户端都有哪些？

186.jedis 和 redisson 有哪些区别？

187.怎么保证缓存和数据库数据的一致性？

188.redis 持久化有几种方式？

189.redis 怎么实现分布式锁？

190.redis 分布式锁有什么缺陷？

191.redis 如何做内存优化？

192.redis 淘汰策略有哪些？

193.redis 常见的性能问题有哪些？该如何解决？

> ## JVM

**194.说一下 jvm 的主要组成部分？及其作用？**
```
1.类加载器（Class Loader）：加载类文件到内存。Class loader只管加载，只要符合文件结构就加载，至于能否运行，它不负责，那是有Exectution Engine 负责的。

2.执行引擎（Execution Engine）：也叫解释器，负责解释命令，交由操作系统执行。

3.本地库接口（Native Interface）：本地接口的作用是融合不同的语言为java所用

4.运行时数据区（Runtime Data Area）：堆栈方法区那些
```

**195.说一下 jvm 运行时数据区？**
```
（1）堆。堆是java对象的存储区域，任何用new字段分配的java对象实例和数组，都被分配在堆上，java堆可用-Xms和-Xmx进行内存控制，jdk1.7以后，运行时常量池从方法区移到了堆上。
（2）方法区：用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
　　误区：方法区不等于永生代
　　很多人原因把方法区称作“永久代”（Permanent Generation），本质上两者并不等价，只是HotSpot虚拟机垃圾回收器团队把GC分代收集扩展到了方法区，或者说是用来永久代来实现方法区而已，这样能省去专门为方法区编写内存管理的代码，但是在Jdk8也移除了“永久代”，使用Native Memory来实现方法区。
（3）虚拟机栈：虚拟机栈中执行每个方法的时候，都会创建一个栈桢用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
（4）本地方法栈：与虚拟机发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的Native方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
（5）程序计数器。指示Java虚拟机下一条需要执行的字节码指令。
```

**196.说一下堆栈的区别？**
```
    栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。

    堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。
```

**197.队列和栈是什么？有什么区别？**
```
（1）操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。

（2）可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。

（3）操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。

队列和栈都是被用来预存数据的。
队列允许先进先出检查元素，但也有例外情况。Deque接口允许从两端检索元素。
栈和队列相似，但他运行对元素后进先出进行检索。
```

**198.什么是双亲委派模型？**
```
当需要加载一个类的时候，子类加载器并不会马上去加载，而是依次去请求父类加载器加载，一直往上请求到最高类加载器：启动类加载器。当启动类加载器加载不了的时候，依次往下让子类加载器进行加载。当达到最底下的时候，如果还是加载不到该类，就会出现ClassNotFound的情况。

好处：保证了程序的安全性。例子：比如我们重新写了一个String类，加载的时候并不会去加载到我们自己写的String类，因为当请求上到最高层的时候，启动类加载器发现自己能够加载String类，因此就不会加载到我们自己写的String类了。
```

**199.说一下类加载的执行过程？**
```
举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。

由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。

类加载
类加载的过程主要分为三个部分：加载\链接\初始化
而链接又可以细分为三个小部分：验证\准备\解析

https://blog.csdn.net/ln152315/article/details/79223441
```

**200.怎么判断对象是否可以被回收？**
```
一、引用计数算法：
　　判断对象的引用数量：
　　　　通过判断对象的引用数量来决定对象是否可以被回收；每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1；任何引用计数为0的对象实例可以被当作垃圾收集；

　　优缺点：
　　　　优点：执行效率高，程序执行受影响较小；
　　　　缺点：无法检测出循环引用的情况，导致内存泄漏；

二、可达性分析算法：
　　通过判断对象的引用链是否可达来决定对象是否可以被回收；从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链时，则认为此对象可以被回收。大家可以认为就是一个树的根节点开始计算引用情况。

　　可以作为GC Root的对象有：
　　　　虚拟机栈中引用的对象（栈帧中的本地变量表）；
　　　　方法区中的常量引用对象；
　　　　方法区中类静态属性引用对象；
　　　　本地方法栈中JNI（Native方法）的引用对象；
　　　　活跃线程中的引用对象；
```

**201.java 中都有哪些引用类型？**
```
无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用”离不开关系。如今，将引用分为强引用、软引用、弱引用和虚引用4种，强度依次减弱。

1、强引用：发生GC的时候不会被回收。
2、软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
3、弱引用：有用但不是必须的对象，在下一次GC的时候会被回收。
4、虚引用：无法通过虚引用获得对象，用PhantomReference实现虚引用，虚引用的用途是在GC时返回一个通知。
```

**202.说一下 jvm 有哪些垃圾回收算法？**
```
常用的垃圾回收算法有四种：标记-清除算法、复制算法、标记-整理算法、分代收集算法。

1.标记-清除算法
分为标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象，如下图。缺点：标记和清除两个过程效率都不高；标记清除之后会产生大量不连续的内存碎片。
2.复制算法
把内存分为大小相等的两块，每次存储只用其中一块，当这一块用完了，就把存活的对象全部复制到另一块上，同时把使用过的这块内存空间全部清理掉，往复循环，如下图。缺点：实际可使用的内存空间缩小为原来的一半，比较适合。
3.标记-整理算法
先对可用的对象进行标记，然后所有被标记的对象向一段移动，最后清除可用对象边界以外的内存，如下图。
4.分代收集算法
把堆内存分为新生代和老年代，新生代又分为 Eden 区、From Survivor 和 To Survivor。一般新生代中的对象基本上都是朝生夕灭的，每次只有少量对象存活，因此采用复制算法，只需要复制那些少量存活的对象就可以完成垃圾收集；老年代中的对象存活率较高，就采用标记-清除和标记-整理算法来进行回收。
```

**203.说一下 jvm 有哪些垃圾回收器？**
```
一、串行垃圾回收器
二、并行垃圾回收器
三、CMS收集器
四、G1垃圾收集器
```

**204.详细介绍一下 CMS 垃圾回收器？**
```
    CMS（Concurrent Mark Sweep）收集器是一种以获得最短回收停顿时间为目标的收集器。从名字就能知道它是标记-清除算法的。但是它比一般的标记-清除算法要复杂一些，分为以下4个阶段：
    - 初始标记：标记一下GC Roots能直接关联到的对象，会"Stop The World"。
    - 并发标记：GC Roots Tracing，可以和用户线程并发执行。
    - 重新标记：标记期间产生的对象存活的再次判断，修正对这些对象的标记，执行时间相对并发标记短，会“Stop The World”.
    - 并发清除：清除对象，可以和用户线程并发执行。
    由于垃圾回收线程可以和用户线程同时运行，也就是说它是并发的，那么它会对CPU的资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/ 4，当CPU<4个时，并发回收是垃圾收集线程就不会少于25%，而且随着CPU减少而增加，这样会影响用户线程的执行。而且由于它是基于标记-清除算法的，那么就无法避免空间碎片的产生。CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。

    所谓浮动垃圾，在CMS并发清理阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只能留待下一次GC时再清理掉。
```

**205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？**


**206.简述分代垃圾回收器是怎么工作的？**
```
分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。

新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：

把 Eden + From Survivor 存活的对象放入 To Survivor 区；
清空 Eden 和 From Survivor 分区；
From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。

每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。

老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程
————————————————
原文链接：https://blog.csdn.net/miachen520/article/details/104908811
```

**207.说一下 jvm 调优的工具？**
```
jvm监控分析工具一般分为两类，一种是jdk自带的工具，一种是第三方的分析工具。jdk自带工具一般在jdk bin目录下面，以exe的形式直接点击就可以使用，其中包含分析工具已经很强大，几乎涉及了方方面面，但是我们最常使用的只有两款：jconsole.exe和jvisualvm.exe；第三方的分析工具有很多，各自的侧重点不同，比较有代表性的：MAT(Memory Analyzer Tool)、GChisto等。
```

**208.常用的 jvm 调优的参数都有哪些？**
```
-Xms2g：初始化推大小为 2g；
-Xmx2g：堆最大内存为 2g；
-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
-XX:+PrintGC：开启打印 gc 信息；
-XX:+PrintGCDetails：打印 gc 详细信息。
```
————————————————

原文链接：https://blog.csdn.net/sufu1065/article/details/88051083