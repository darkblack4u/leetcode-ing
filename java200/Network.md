> ## 网络

**79.http 响应码 301 和 302 代表的是什么？有什么区别？**
```
301 moved permanently、302 found、303 see other

301/302/303都表示重定向，所以放在一起讲解。

301表示永久重定向（301 moved permanently），表示请求的资源分配了新url，以后应使用新url。

302表示临时性重定向（302 found），请求的资源临时分配了新url，本次请求暂且使用新url。302与301的区别是，302表示临时性重定向，重定向的url还有可能还会改变。

303 表示请求的资源路径发生改变，使用GET方法请求新url。她与302的功能一样，但是明确指出使用GET方法请求新url。
————————————————
原文链接：https://blog.csdn.net/wangjun5159/article/details/51239960
```

**80. forward 和 redirect 的区别？**
```
是servlet种的两种主要的跳转方式。forward又叫转发，redirect叫做重定向。
1. 从地址栏显示来说：
    1）forword是服务器内部的重定向，服务器直接访问目标地址的 url网址，把里面的东西读取出来，但是客户端并不知道，因此用forward的话，客户端浏览器的网址是不会发生变化的。
    2）redirect是服务器根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，所以地址栏显示的是新的地址。
2。 从数据共享来说：
    1）由于在整个定向的过程中用的是同一个request，因此forward会将request的信息带到被重定向的jsp或者servlet中使用。即可以共享数据
    2）redirect不能共享
3. 从运用的地方来说
    1）forword 一般用于用户登录的时候，根据角色转发到相应的模块
    2）redirect一般用于用户注销登录时返回主页面或者跳转到其他网站
4。 从效率来说：
    1）forword效率高，而redirect效率低
5. 从本质来说：
    forword转发是服务器上的行为，而redirect重定向是客户端的行为
————————————————
原文链接：https://blog.csdn.net/weixin_37766296/article/details/80375106
```

**81. 简述 tcp 和 udp的区别？**
```
TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，三次对话建立连接，四次对话断开连接。
UDP的包头结构：源端口 16位 目的端口 16位 长度 16位 校验和 16位
小结TCP与UDP的区别：
1、基于连接与无连接；
2、对系统资源的要求（TCP较多，UDP少）；
3、UDP程序结构较简单；
4、流模式与数据报模式 ；
5、TCP保证数据正确性，UDP可能丢包；
6、TCP保证数据顺序，UDP不保证。
```

**82. tcp 为什么要三次握手，两次不行吗？为什么？**
```
这样的两次握手过程， A 向 B 打招呼得到了回应，即 A 向 B 发送数据，B 是可以收到的。
但是 B 向 A 打招呼，A 还没有回应，B 没有收到 A 的反馈，无法确保 A 可以收到 B 发送的数据。
只有经过第三次握手，才能确保双向都可以接收到对方的发送的 数据。
```

**83.说一下 tcp 粘包是怎么产生的？**
```
1.Q：什么是TCP粘包问题？
    TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。

2.Q：造成TCP粘包的原因
（1）发送方原因

    TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：

    1 只有上一个分组得到确认，才会发送下一个分组
    2 收集多个小分组，在一个确认到来时一起发送
    3 Nagle算法造成了发送方可能会出现粘包问题

（2）接收方原因

    TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

3.Q：什么时候需要处理粘包现象？
    如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象，如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了
4.Q：如何处理粘包现象？
    （1）发送方
    对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。
    （2）接收方
    接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。
    （2）应用层
    应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。

    解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？
    格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。
    发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。

原文链接：https://blog.csdn.net/weixin_41047704/article/details/85340311
```

**84. OSI 的七层模型都有哪些？**
```
OSI模型分为七层，自下而上为 物理层（Physical Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表达层（Presentation Layer）、应用层（Application Layer）。

TCP/IP四层概念模型: 应用层，传输层，网络层，数据传输层
————————————————
https://blog.csdn.net/meism5/article/details/90414270
```

**85. get 和 post 请求有哪些区别？**

**86.如何实现跨域？**
```
JSONP：通过动态创建script，再请求一个带参网址实现跨域通信。document.domain + iframe跨域：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

JSONP：ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。

location.hash + iframe跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

window.name + iframe跨域：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。

postMessage跨域：可以跨域操作的window属性之一。

CORS：服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求，前后端都需要设置。

代理跨域：起一个代理服务器，实现数据的转发
```

87.说一下 JSONP 实现原理？