> # 关于GC

> **`内存溢出异常`**

内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。

但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：`长生命周期的对象持有短生命周期对象的引用`就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。


> **`GC是什么？为什么要GC`**

GC 是垃圾收集的意思（Gabage Collection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。

> **`简述Java垃圾回收机制`**

在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

> **`垃圾回收的优点和原理。`**

java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。垃圾回收机制有效的防止了`内存泄露`，可以有效的使用可使用的内存。垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。

> **`怎么判断对象是否可以被回收？`**

1. 引用计数算法：
    - 判断对象的引用数量：通过判断对象的引用数量来决定对象是否可以被回收；每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1；任何引用计数为0的对象实例可以被当作垃圾收集；
    - 优缺点：
        - 优点：执行效率高，程序执行受影响较小；
        - 缺点：无法检测出循环引用的情况，导致内存泄漏；
2. 可达性分析算法：
    - 通过判断对象的引用链是否可达来决定对象是否可以被回收；从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链时，则认为此对象可以被回收。大家可以认为就是一个树的根节点开始计算引用情况。
    - 可以作为GC Root的对象有：
        - `虚拟机栈中引用的对象（栈帧中的本地变量表）`；
        - `方法区中的常量引用对象`；
        - `方法区中类静态属性引用对象`；
        - `本地方法栈中JNI（Native方法）的引用对象`；
        - `活跃线程中的引用对象`；

> **`java 中都有哪些引用类型？`**

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用”离不开关系。如今，将引用分为强引用、软引用、弱引用和虚引用4种，强度依次减弱。

1. 强引用：发生GC的时候`不会`被回收。
2. 软引用：有用但不是必须的对象，在发生`内存溢出之前`会被回收。
3. 弱引用：有用但不是必须的对象，在下一次`GC`的时候会被回收。
4. 虚引用：无法通过虚引用获得对象，用PhantomReference实现虚引用，虚引用的用途是在GC时返回一个通知。

> **`说一下 jvm 有哪些垃圾回收算法？`**

常用的垃圾回收算法有四种：标记-清除算法、复制算法、标记-整理算法、分代收集算法。

1. `标记-清除算法`
分为标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象，如下图。缺点：标记和清除两个过程效率都不高；标记清除之后会产生大量不连续的内存碎片。
2. `复制算法`
把内存分为大小相等的两块，每次存储只用其中一块，当这一块用完了，就把存活的对象全部复制到另一块上，同时把使用过的这块内存空间全部清理掉，往复循环，如下图。缺点：实际可使用的内存空间缩小为原来的一半，比较适合。copy算法是在新生代执行的，因为新生代对象大多朝生夕灭，存活时间短，占内存小，所以一次gc后剩下的对象少而且小，直接从from survivor和eden区copy到to survivor就好了，这叫minor gc。
3. `标记-整理算法`
先对可用的对象进行标记，然后所有被标记的对象向一段移动，最后清除可用对象边界以外的内存，如下图。标记整理是老年代常用的，因为老年代对象大而且生存时间长，不适合用copy算法，这叫major gc。
4. `分代收集算法`
把堆内存分为新生代和老年代，新生代又分为 Eden 区、From Survivor 和 To Survivor。一般新生代中的对象基本上都是朝生夕灭的，每次只有少量对象存活，因此采用复制算法，只需要复制那些少量存活的对象就可以完成垃圾收集；老年代中的对象存活率较高，就采用标记-清除和标记-整理算法来进行回收。

> **`说一下 jvm 有哪些垃圾回收器？`**

![image](https://img-blog.csdnimg.cn/img_convert/2cb2785445d03d6196023b841490a624.png)

1. 串行垃圾回收器
2. 并行垃圾回收器
3. CMS收集器
4. G1垃圾收集器

> **`详细介绍一下 CMS 垃圾回收器？`**

![iamge](https://c1.staticflickr.com/5/4740/40093687062_7383cd1b49_z.jpg)

CMS（Concurrent Mark Sweep）收集器是一种以获得最短回收停顿时间为目标的收集器。从名字就能知道它是标记-清除算法的。但是它比一般的标记-清除算法要复杂一些，分为以下4个阶段：
- 初始标记：标记一下GC Roots能直接关联到的对象，会"Stop The World"。
- 并发标记：GC Roots Tracing，可以和用户线程并发执行。
- 重新标记：标记期间产生的对象存活的再次判断，修正对这些对象的标记，执行时间相对并发标记短，会“Stop The World”.
- 并发清除：清除对象，可以和用户线程并发执行。
    
由于垃圾回收线程可以和用户线程同时运行，也就是说它是并发的，那么它会对`CPU的资源非常敏感`，CMS默认启动的回收线程数是（CPU数量+3）/ 4，当CPU<4个时，并发回收是垃圾收集线程就不会少于25%，而且随着CPU减少而增加，这样会影响用户线程的执行。而且由于它是基于标记-清除算法的，那么就无法避免空间碎片的产生。CMS收集器无法处理`浮动垃圾（Floating Garbage）`，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。所谓浮动垃圾，在CMS并发清理阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只能留待下一次GC时再清理掉。

> **`CMS常用参数`**

- -XX:+UseConcMarkSweepGC 该标志首先是激活CMS收集器。默认HotSpot JVM使用的是并行收集器。                                   
- -XX:ParallelCMSThreads=20 设定其中ParallelGCThreads是年轻代的并行收集线程数CMS默认启动的回收线程数目是(ParallelGCThreads + 3)/4) 。
- -XX:CMSInitiatingOccupancyFraction=80 : 手动指定当老年代已用空间达到80%时，触发老年代回收(默认92%)
- -XX:+DisableExplicitGC : 手动配置禁止使用外部调用System.gc 来进行触发垃圾回收
- -XX:MaxGCPauseMillis=100这个参数用于设置GC暂停等待时间，单位为毫秒，不要设置过低一般在100-200ms
- -XX:+UseCMSCompactAtFullCollection : 在进行Full GC时对内存进行压缩
- -XX:+CMSScavengeBeforeRemark  在CMS GC前启动一次ygc，目的在于减少old gen对ygc gen的引用，降低remark时的开销-----一般CMS的GC耗时 80%都在remark阶段
- -XX:CMSFullGCsBeforeCompaction=2 : 与-XX:+UseCMSCompactAtFullCollection 关联使用标识着每经过多少次Full GC 触发对内存进行一次压缩，默认是0次.
- -XX:+CMSClassUnloadingEnabled : 手动指定CMS 收集器对非堆区域永久代进行回收，默认永久代不回收

> **`G1垃圾收集器`**

![image](https://c1.staticflickr.com/5/4655/28345836209_7b70465317_b.jpg)

![image](https://c1.staticflickr.com/5/4678/40093686972_25da5b859f_z.jpg)

> **`206.简述分代垃圾回收器是怎么工作的？`**

分代回收器有两个分区：`老生代`和`新生代`，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。

新生代使用的是`复制算法`，新生代里有 3 个分区：`Eden`、`To Survivor`、`From Survivor`，它们的默认占比是 8:1:1，它的执行流程如下：

- 把 Eden + From Survivor 存活的对象放入 To Survivor 区；
- 清空 Eden 和 From Survivor 分区；
- From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。
- 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。
- 老生代当空间占用到达某个值之后就会触发全局垃圾(Full GC)收回，一般使用`标记整理`的执行算法。

以上这些循环往复就构成了整个分代垃圾回收的整体执行流程

> **`JVM中的永久代中会发生垃圾回收吗`**

`垃圾回收不会发生在永久代`，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区.

> **`大对象直接进入老年代`**
```
所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。
前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。
```

> **`长期存活对象将进入老年代`**
```
虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。
```

> **`对象优先在 Eden 区分配`**

多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。

这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC/Full GC。
- `Minor GC `是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；
- `Major GC/Full GC` 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。

> **`常用的 jvm 调优的参数都有哪些？`**

- -Xms2g：初始化推大小为 2g；
- -Xmx2g：堆最大内存为 2g；
- -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
- -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
- –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
- -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
- -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
- -XX:+PrintGC：开启打印 gc 信息；
- -XX:+PrintGCDetails：打印 gc 详细信息。

> **`新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？`**

![image](https://img-blog.csdnimg.cn/img_convert/2cb2785445d03d6196023b841490a624.png)
